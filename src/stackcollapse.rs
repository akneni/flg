//! Stack collapse for perf script output.
//!
//! Parses multiline stacks generated by `perf script` and outputs semicolon-separated
//! stacks followed by a space and a count. Identical stacks are collapsed with their
//! counts summed.
//!
//! # Example
//!
//! ```
//! use stackcollapse_perf::{collapse_perf, Options};
//!
//! let input = r#"
//! swapper     0 [000] 158665.570607: cpu-clock:
//!         ffffffff8103ce3b native_safe_halt ([kernel.kallsyms])
//!         ffffffff8101c6a3 default_idle ([kernel.kallsyms])
//!
//! "#;
//!
//! let opts = Options::default();
//! let result = collapse_perf(input, &opts);
//! ```

use std::collections::HashMap;
use std::io::{BufRead, BufReader, Read};
use std::process::Command;

pub struct Stack {
    stack: String,
    num_occurances: u64,
    width: u64,
}

/// Configuration options for stack collapsing.
#[derive(Debug, Clone)]
pub struct Options {
    /// Annotate kernel functions with `_[k]`
    pub annotate_kernel: bool,
    /// Annotate JIT functions with `_[j]`
    pub annotate_jit: bool,
    /// Include process names in stacks
    pub include_pname: bool,
    /// Include process ID with process name
    pub include_pid: bool,
    /// Include thread ID with process name
    pub include_tid: bool,
    /// Include raw addresses where symbols can't be found
    pub include_addrs: bool,
    /// Condense Java signatures
    pub tidy_java: bool,
    /// Clean up function names
    pub tidy_generic: bool,
    /// Event type filter (empty string means use first encountered)
    pub event_filter: String,
    /// Use addr2line for inline expansion
    pub show_inline: bool,
    /// Add source context to inline output
    pub show_context: bool,
    /// Parse source line info from `perf script -F+srcline`
    pub srcline_in_input: bool,
}

impl Default for Options {
    fn default() -> Self {
        Self {
            annotate_kernel: false,
            annotate_jit: false,
            include_pname: true,
            include_pid: false,
            include_tid: false,
            include_addrs: false,
            tidy_java: true,
            tidy_generic: true,
            event_filter: String::new(),
            show_inline: false,
            show_context: false,
            srcline_in_input: false,
        }
    }
}

impl Options {
    /// Enable all annotations (kernel and JIT).
    pub fn with_all_annotations(mut self) -> Self {
        self.annotate_kernel = true;
        self.annotate_jit = true;
        self
    }
}

/// Result of stack collapsing: maps folded stack strings to their counts.
pub type CollapsedStacks = HashMap<String, u64>;

/// Internal state for the parser.
struct Parser<'a> {
    opts: &'a Options,
    collapsed: CollapsedStacks,
    stack: Vec<String>,
    pname: Option<String>,
    pid: String,
    tid: String,
    period: u64,
    event_filter: String,
    event_defaulted: bool,
    event_warning_printed: bool,
    inline_cache: HashMap<(String, String), String>,
    nm_cache: HashMap<String, String>,
}

impl<'a> Parser<'a> {
    fn new(opts: &'a Options) -> Self {
        Self {
            opts,
            collapsed: HashMap::new(),
            stack: Vec::new(),
            pname: None,
            pid: String::new(),
            tid: String::new(),
            period: 1,
            event_filter: opts.event_filter.clone(),
            event_defaulted: false,
            event_warning_printed: false,
            inline_cache: HashMap::new(),
            nm_cache: HashMap::new(),
        }
    }

    fn remember_stack(&mut self) {
        if self.stack.is_empty() {
            return;
        }

        let mut full_stack = self.stack.clone();
        full_stack.reverse();

        if self.opts.include_pname {
            if let Some(ref pname) = self.pname {
                full_stack.insert(0, pname.clone());
            }
        }

        let key = full_stack.join(";");
        *self.collapsed.entry(key).or_insert(0) += self.period;
    }

    /// Attempt to resolve inlined functions using addr2line.
    fn resolve_inline(&mut self, pc: &str, rawfunc: &str, module: &str) -> Option<String> {
        let cache_key = (pc.to_string(), module.to_string());
        if let Some(cached) = self.inline_cache.get(&cache_key) {
            return if cached.is_empty() {
                None
            } else {
                Some(cached.clone())
            };
        }

        // Try addr2line
        let output = Command::new("addr2line")
            .args(["-a", pc, "-e", module, "-i", "-f", "-s", "-C"])
            .output()
            .ok()?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let lines: Vec<&str> = stdout.lines().skip(1).collect(); // Skip first line (address)

        // Check for failure
        if stdout.contains("??") && stdout.contains("??:0") {
            // Try fallback using nm if rawfunc contains offset
            if let Some(result) = self.try_nm_fallback(pc, rawfunc, module) {
                self.inline_cache.insert(cache_key, result.clone());
                return Some(result);
            }
            self.inline_cache.insert(cache_key, String::new());
            return None;
        }

        let mut funcs = Vec::new();
        let mut iter = lines.iter().peekable();

        while let Some(&func_line) = iter.next() {
            let func = func_line.trim();
            if let Some(&loc_line) = iter.next() {
                let loc = loc_line.trim().replace(" (discriminator ", ":");
                let loc = loc.trim_end_matches(')');
                
                if self.opts.show_context {
                    funcs.push(format!("{}:{}", func, loc));
                } else {
                    funcs.push(func.to_string());
                }
            }
        }

        funcs.reverse();
        let result = funcs.join(";");
        self.inline_cache.insert(cache_key, result.clone());

        if result.is_empty() || result == "??" || result == "??:??:0" {
            None
        } else {
            Some(result)
        }
    }

    fn try_nm_fallback(&mut self, pc: &str, rawfunc: &str, module: &str) -> Option<String> {
        // Parse func+0xoffset format
        let parts: Vec<&str> = rawfunc.splitn(2, "+0x").collect();
        if parts.len() != 2 {
            return None;
        }

        let func = parts[0];
        let offset = u64::from_str_radix(parts[1], 16).ok()?;

        // Get or populate nm cache
        if !self.nm_cache.contains_key(module) {
            let output = Command::new("nm").arg(module).output().ok()?;
            let stdout = String::from_utf8_lossy(&output.stdout).to_string();
            self.nm_cache.insert(module.to_string(), stdout);
        }

        let nm_output = self.nm_cache.get(module)?;

        // Find the symbol base address
        for line in nm_output.lines() {
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 3 && parts[2] == func {
                let base = u64::from_str_radix(parts[0], 16).ok()?;
                let new_pc = format!("0x{:x}", base + offset);
                return self.resolve_inline(&new_pc, "", module);
            }
        }

        None
    }

    fn parse_event_record(&mut self, line: &str) -> bool {
        // Parse lines like:
        // "java 25607 4794564.109216: 1 cycles:"
        // "java 12688 [002] 6544038.708352: 235 cpu-clock:"
        // "java 24636/25607 [000] 4794564.109216: 1 cycles:"
        // "V8 WorkerThread 25607 4794564.109216: 104345 cycles:"

        // Find the position after comm and pid/tid
        let re_result = parse_event_header(line);
        
        if let Some((comm, pid, tid, period, event)) = re_result {
            // Event filtering
            if self.event_filter.is_empty() {
                self.event_filter = event.clone();
                self.event_defaulted = true;
            } else if event != self.event_filter {
                if self.event_defaulted && !self.event_warning_printed {
                    eprintln!("Filtering for events of type: {}", self.event_filter);
                    self.event_warning_printed = true;
                }
                return false;
            }

            self.pid = pid;
            self.tid = tid;
            self.period = period;

            let pname = if self.opts.include_tid {
                format!("{}-{}/{}", comm, self.pid, self.tid)
            } else if self.opts.include_pid {
                format!("{}-{}", comm, self.pid)
            } else {
                comm
            };

            self.pname = Some(pname.replace(' ', "_"));
            true
        } else {
            false
        }
    }

    fn parse_stack_line(&mut self, line: &str, next_line: Option<&str>) {
        // Parse lines like:
        // "        ffffffff8103ce3b native_safe_halt ([kernel.kallsyms])"
        // "        7fffb84c9afc cpu_startup_entry+0x800047c022ec ([kernel.kallsyms])"

        let trimmed = line.trim();
        
        // Match: <pc> <rawfunc> (<module>)
        let parts = parse_stack_frame(trimmed);
        
        if let Some((pc, rawfunc, module)) = parts {
            // Try inline resolution if enabled
            if self.opts.show_inline && !is_special_module(&module) {
                if let Some(inline_result) = self.resolve_inline(&pc, &rawfunc, &module) {
                    for func in inline_result.split(';') {
                        self.stack.push(func.to_string());
                    }
                    return;
                }
            }

            // Strip offset from function name (Linux 4.8+)
            let rawfunc = strip_offset(&rawfunc);

            // Skip process names in parens
            if rawfunc.starts_with('(') {
                return;
            }

            // Process inline arrows (func1->func2->func3)
            let mut funcs = Vec::new();
            let mut is_unknown = false;

            for part in rawfunc.split("->") {
                let mut func = part.to_string();

                if func == "[unknown]" {
                    is_unknown = true;
                    if module != "[unknown]" {
                        // Use module name instead
                        func = module
                            .rsplit('/')
                            .next()
                            .unwrap_or(&module)
                            .to_string();
                    } else {
                        func = "unknown".to_string();
                    }

                    func = if self.opts.include_addrs {
                        format!("[{} <{}>]", func, pc)
                    } else {
                        format!("[{}]", func)
                    };
                }

                if self.opts.tidy_generic {
                    func = tidy_generic_func(&func);
                }

                if self.opts.tidy_java && self.pname.as_ref().map_or(false, |p| p.starts_with("java")) {
                    func = tidy_java_func(&func);
                }

                // Annotations
                if !funcs.is_empty() && !func.contains("_[i]") {
                    func.push_str("_[i]"); // inlined
                } else if self.opts.annotate_kernel && is_kernel_module(&module) {
                    func.push_str("_[k]");
                } else if self.opts.annotate_jit && is_jit_module(&module) && !func.contains("_[j]") {
                    func.push_str("_[j]");
                }

                // Source line handling
                if self.opts.srcline_in_input && !is_unknown {
                    if let Some(srcline) = next_line {
                        let srcline = srcline.trim();
                        // Remove bracketed parts and trim
                        let srcline = remove_brackets(srcline);
                        if !srcline.is_empty() {
                            func = format!("{}:{}", func, srcline);
                        }
                    }
                }

                funcs.push(func);
            }

            for func in funcs {
                self.stack.push(func);
            }
        }
    }

    fn finish(&mut self) {
        // Handle any remaining stack
        if self.pname.is_some() && !self.stack.is_empty() {
            self.remember_stack();
        }
    }
}

/// Parse an event header line, returning (comm, pid, tid, period, event).
fn parse_event_header(line: &str) -> Option<(String, String, String, u64, String)> {
    // This is a simplified parser for the common formats
    // Looking for patterns like:
    //   comm pid[/tid] [cpu] time: [period] event:

    let line = line.trim();
    
    // Find the colon that ends the event type
    let event_end = line.rfind(':')?;
    let before_event_colon = &line[..event_end];
    
    // Find the previous space to get the event type
    let event_start = before_event_colon.rfind(' ')? + 1;
    let event = line[event_start..event_end].to_string();
    
    // Look for period before the event
    let before_event = &line[..event_start].trim_end();
    let period_and_rest = before_event.rsplit_once(' ')?;
    
    // Check if the last part before event is a number (period) or a colon-timestamp
    let (rest, period) = if let Ok(p) = period_and_rest.1.parse::<u64>() {
        (period_and_rest.0, p)
    } else {
        // No explicit period, default to 1
        (*before_event, 1u64)
    };

    // Now find timestamp (contains '.' and ends with ':')
    // Work backwards to find comm pid/tid
    let rest = rest.trim_end_matches(':');
    
    // Find comm and pid/tid at the start
    // Format: "comm pid[/tid] ..."
    let mut parts = rest.split_whitespace();
    
    // Collect all parts that could be the command name
    // The pid/tid is the first numeric part or numeric/numeric
    let mut comm_parts = Vec::new();
    let mut pid = String::from("?");
    let mut tid = String::from("?");
    
    for part in parts {
        // Check if this looks like pid or pid/tid
        if let Some((p, t)) = part.split_once('/') {
            if p.chars().all(|c| c.is_ascii_digit()) {
                pid = p.to_string();
                tid = t.to_string();
                break;
            }
        } else if part.chars().all(|c| c.is_ascii_digit()) {
            pid = part.to_string();
            tid = part.to_string();
            break;
        }
        
        // Check if it's a CPU marker [###]
        if part.starts_with('[') && part.ends_with(']') {
            continue;
        }
        
        // Check if it looks like a timestamp
        if part.contains('.') && part.chars().all(|c| c.is_ascii_digit() || c == '.') {
            continue;
        }
        
        comm_parts.push(part);
    }
    
    let comm = comm_parts.join(" ");
    
    if comm.is_empty() {
        return None;
    }
    
    Some((comm, pid, tid, period, event))
}

/// Parse a stack frame line, returning (pc, rawfunc, module).
fn parse_stack_frame(line: &str) -> Option<(String, String, String)> {
    // Format: "<pc> <rawfunc> (<module>)"
    // Or: "<pc> <rawfunc> (<module>)" with srcline on next line
    
    // Find the module in parentheses at the end
    let paren_end = line.rfind(')')?;
    let paren_start = line[..paren_end].rfind('(')?;
    let module = line[paren_start + 1..paren_end].to_string();
    
    let before_module = line[..paren_start].trim();
    
    // First word is PC, rest is rawfunc
    let space_idx = before_module.find(char::is_whitespace)?;
    let pc = before_module[..space_idx].to_string();
    let rawfunc = before_module[space_idx..].trim().to_string();
    
    Some((pc, rawfunc, module))
}

/// Strip +0x... offset from function name.
fn strip_offset(func: &str) -> String {
    if let Some(idx) = func.rfind("+0x") {
        // Make sure what follows looks like hex
        let after = &func[idx + 3..];
        if after.chars().all(|c| c.is_ascii_hexdigit()) {
            return func[..idx].to_string();
        }
    }
    func.to_string()
}

/// Clean up generic function names.
fn tidy_generic_func(func: &str) -> String {
    let mut result = func.replace(';', ":");
    
    // Remove template/generic parameters unless it looks like a Go method
    if !result.contains(".(") || !result.contains(").") {
        // Not a Go method, remove everything after first paren
        // (unless it's "anonymous namespace")
        if let Some(idx) = result.find('(') {
            if !result[idx..].starts_with("(anonymous namespace)") {
                result = result[..idx].to_string();
            }
        }
    }
    
    // Remove quotes
    result = result.replace(['"', '\''], "");
    
    result
}

/// Clean up Java function names.
fn tidy_java_func(func: &str) -> String {
    let mut result = func.to_string();
    
    // Remove leading 'L' from class names that contain '/'
    if result.starts_with('L') && result.contains('/') {
        result = result[1..].to_string();
    }
    
    result
}

/// Check if module indicates kernel code.
fn is_kernel_module(module: &str) -> bool {
    (module.starts_with('[') || module.ends_with("vmlinux")) && !module.contains("unknown")
}

/// Check if module indicates JIT code.
fn is_jit_module(module: &str) -> bool {
    // Match /tmp/perf-<pid>.map
    module.contains("/tmp/perf-") && module.ends_with(".map")
}

/// Check if module is a special module that shouldn't be addr2line'd.
fn is_special_module(module: &str) -> bool {
    module.contains("perf-") && module.ends_with(".map")
        || module.contains("kernel.")
        || (module.starts_with('[') && module.ends_with(']'))
}

/// Remove bracketed portions from a string.
fn remove_brackets(s: &str) -> String {
    let mut result = String::new();
    let mut depth: i32 = 0;
    
    for c in s.chars() {
        match c {
            '[' => depth += 1,
            ']' => depth = depth.saturating_sub(1),
            _ if depth == 0 => result.push(c),
            _ => {}
        }
    }
    
    result.trim().to_string()
}

/// Collapse perf script output into folded stacks.
///
/// # Arguments
///
/// * `input` - The perf script output as a string
/// * `opts` - Configuration options
///
/// # Returns
///
/// A `CollapsedStacks` map from folded stack strings to their counts.
pub fn collapse_perf(input: &str, opts: &Options) -> CollapsedStacks {
    let mut parser = Parser::new(opts);
    let lines: Vec<&str> = input.lines().collect();
    let mut i = 0;
    
    while i < lines.len() {
        let line = lines[i];
        
        // Skip comments
        if line.starts_with('#') {
            i += 1;
            continue;
        }
        
        // Empty line: end of stack
        if line.trim().is_empty() {
            if parser.pname.is_some() {
                parser.remember_stack();
            }
            parser.stack.clear();
            parser.pname = None;
            i += 1;
            continue;
        }
        
        // Try to parse as event record
        if !line.starts_with(char::is_whitespace) {
            if !parser.parse_event_record(line) {
                // Filtered out, skip until next blank line
                parser.pname = None;
            }
            i += 1;
            continue;
        }
        
        // Stack line
        if parser.pname.is_some() {
            let next_line = if opts.srcline_in_input && i + 1 < lines.len() {
                Some(lines[i + 1])
            } else {
                None
            };
            
            parser.parse_stack_line(line, next_line);
            
            // Skip the srcline if we processed it
            if opts.srcline_in_input && next_line.is_some() {
                i += 1;
            }
        }
        
        i += 1;
    }
    
    parser.finish();
    parser.collapsed
}

/// Collapse perf script output from a reader.
pub fn collapse_perf_reader<R: Read>(reader: R, opts: &Options) -> CollapsedStacks {
    let mut content = String::new();
    let mut buf_reader = BufReader::new(reader);
    buf_reader.read_to_string(&mut content).unwrap_or(0);
    collapse_perf(&content, opts)
}

/// Format collapsed stacks as output string (sorted by stack name).
pub fn format_collapsed(collapsed: &CollapsedStacks) -> String {
    let mut sorted: Vec<_> = collapsed.iter().collect();
    sorted.sort_by(|a, b| a.0.cmp(b.0));
    
    sorted
        .into_iter()
        .map(|(stack, count)| format!("{} {}", stack, count))
        .collect::<Vec<_>>()
        .join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_collapse() {
        let input = r#"
swapper     0 [000] 158665.570607: 1 cpu-clock:
        ffffffff8103ce3b native_safe_halt ([kernel.kallsyms])
        ffffffff8101c6a3 default_idle ([kernel.kallsyms])
        ffffffff81013236 cpu_idle ([kernel.kallsyms])

swapper     0 [000] 158665.570608: 1 cpu-clock:
        ffffffff8103ce3b native_safe_halt ([kernel.kallsyms])
        ffffffff8101c6a3 default_idle ([kernel.kallsyms])
        ffffffff81013236 cpu_idle ([kernel.kallsyms])

"#;
        let opts = Options::default();
        let result = collapse_perf(input, &opts);
        
        assert_eq!(result.len(), 1);
        let expected_key = "swapper;cpu_idle;default_idle;native_safe_halt";
        assert!(result.contains_key(expected_key), "Expected key: {}", expected_key);
        assert_eq!(result[expected_key], 2);
    }

    #[test]
    fn test_kernel_annotation() {
        let input = r#"
swapper     0 [000] 158665.570607: 1 cpu-clock:
        ffffffff8103ce3b native_safe_halt ([kernel.kallsyms])

"#;
        let opts = Options {
            annotate_kernel: true,
            ..Default::default()
        };
        let result = collapse_perf(input, &opts);
        
        assert!(result.keys().next().unwrap().contains("_[k]"));
    }

    #[test]
    fn test_pid_inclusion() {
        let input = r#"
java 12345 158665.570607: 1 cpu-clock:
        7fff12345678 some_func (/path/to/lib.so)

"#;
        let opts = Options {
            include_pid: true,
            ..Default::default()
        };
        let result = collapse_perf(input, &opts);
        
        let key = result.keys().next().unwrap();
        assert!(key.starts_with("java-12345;"), "Key was: {}", key);
    }

    #[test]
    fn test_strip_offset() {
        assert_eq!(strip_offset("func+0x1234"), "func");
        assert_eq!(strip_offset("func+0xabcdef"), "func");
        assert_eq!(strip_offset("func"), "func");
        assert_eq!(strip_offset("func+notoffset"), "func+notoffset");
    }

    #[test]
    fn test_tidy_generic() {
        assert_eq!(tidy_generic_func("foo(int, int)"), "foo");
        assert_eq!(tidy_generic_func("foo;bar"), "foo:bar");
        // Go methods should be preserved
        assert_eq!(
            tidy_generic_func("net/http.(*Client).Do"),
            "net/http.(*Client).Do"
        );
    }

    #[test]
    fn test_format_collapsed() {
        let mut collapsed = CollapsedStacks::new();
        collapsed.insert("a;b;c".to_string(), 10);
        collapsed.insert("x;y;z".to_string(), 5);
        
        let output = format_collapsed(&collapsed);
        assert!(output.contains("a;b;c 10"));
        assert!(output.contains("x;y;z 5"));
    }
}