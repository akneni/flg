</div>
</div>

<div class="tooltip" id="tooltip">
    <div class="tooltip-name" id="tooltipName"></div>
    <dl class="tooltip-stats">
        <dt>Samples</dt>
        <dd id="tooltipSamples"></dd>
        <dt>Percentage</dt>
        <dd id="tooltipPct"></dd>
        <dt>Self</dt>
        <dd id="tooltipSelf"></dd>
    </dl>
</div>

<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="hideStack">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94" />
            <path d="M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19" />
            <path d="m1 1 22 22" />
        </svg>
        <span>Hide this stack</span>
    </div>
    <div class="context-menu-separator"></div>
    <div class="context-menu-item" id="resetHidden">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M1 4v6h6" />
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" />
        </svg>
        <span>Reset all hidden</span>
    </div>
</div>

<footer>
    <div class="palette-selector">
        <label for="paletteSelect">Color Palette:</label>
        <select id="paletteSelect">
            <option value="warm">Warm</option>
            <option value="cool" selected>Cool</option>
            <option value="neon">Neon</option>
            <option value="pastel">Pastel</option>
            <option value="mono">Monochrome</option>
        </select>
    </div>
    <div class="keyboard-hints">
        <span><kbd>Click</kbd> Zoom in</span>
        <span><kbd>Right-click</kbd> Hide stack</span>
        <span><kbd>Esc</kbd> Reset</span>
        <span><kbd>/</kbd> Search</span>
    </div>
</footer>
</div>

<script>
    (function () {
        const chart = document.getElementById('chart');
        const tooltip = document.getElementById('tooltip');
        const tooltipName = document.getElementById('tooltipName');
        const tooltipSamples = document.getElementById('tooltipSamples');
        const tooltipPct = document.getElementById('tooltipPct');
        const tooltipSelf = document.getElementById('tooltipSelf');
        const searchInput = document.getElementById('search');
        const resetBtn = document.getElementById('resetZoom');
        const clearSearchBtn = document.getElementById('clearSearch');
        const matchedStat = document.getElementById('matchedStat');
        const matchedValue = document.getElementById('matchedValue');
        const contextMenu = document.getElementById('contextMenu');
        const hideStackBtn = document.getElementById('hideStack');
        const resetHiddenBtn = document.getElementById('resetHidden');
        const paletteSelect = document.getElementById('paletteSelect');

        // Color palette functions
        const palettes = {
            warm: (hash) => {
                const hue = (hash % 60) + 0; // Red-orange-yellow range (0-60)
                const sat = 0.70 + ((hash >> 8) % 20) / 100;
                const lit = 0.35 + ((hash >> 16) % 10) / 100;
                return { h: hue, s: sat, l: lit };
            },
            cool: (hash) => {
                const hue = (hash % 120) + 180; // Cyan-blue-purple range (180-300)
                const sat = 0.65 + ((hash >> 8) % 25) / 100;
                const lit = 0.38 + ((hash >> 16) % 12) / 100;
                return { h: hue, s: sat, l: lit };
            },
            neon: (hash) => {
                const hue = hash % 360;
                const sat = 0.90 + ((hash >> 8) % 10) / 100;
                const lit = 0.45 + ((hash >> 16) % 10) / 100;
                return { h: hue, s: sat, l: lit };
            },
            pastel: (hash) => {
                const hue = hash % 360;
                const sat = 0.40 + ((hash >> 8) % 20) / 100;
                const lit = 0.55 + ((hash >> 16) % 15) / 100;
                return { h: hue, s: sat, l: lit };
            },
            mono: (hash) => {
                const hue = 220; // Blue-gray
                const sat = 0.15 + ((hash >> 8) % 10) / 100;
                const lit = 0.25 + ((hash >> 16) % 30) / 100;
                return { h: hue, s: sat, l: lit };
            }
        };

        function hslToRgb(h, s, l) {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (hash * 31 + str.charCodeAt(i)) >>> 0;
            }
            return hash;
        }

        function applyPalette(paletteName) {
            const palette = palettes[paletteName];
            if (!palette) return;

            frames.forEach(f => {
                const name = f.dataset.name;
                if (name === 'all') {
                    f.style.background = 'rgb(99, 102, 241)';
                    return;
                }
                const hash = hashString(name);
                const hsl = palette(hash);
                const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                f.style.background = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            });
        }

        paletteSelect.addEventListener('change', (e) => {
            applyPalette(e.target.value);
        });

        const frames = Array.from(document.querySelectorAll('.frame'));
        const totalSamples = { total_samples };

        let zoomedFrame = null;
        let searchTerm = null;
        let contextTarget = null;
        let hiddenStacks = new Set();

        frames.forEach(f => {
            f.dataset.origStart = f.dataset.start;
            f.dataset.origEnd = f.dataset.end;
            f.dataset.origLeft = f.style.left;
            f.dataset.origWidth = f.style.width;
        });

        function formatNumber(n) { return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ','); }

        function isFrameHidden(frame) {
            const start = parseInt(frame.dataset.origStart);
            const end = parseInt(frame.dataset.origEnd);
            const depth = parseInt(frame.dataset.depth);
            for (const hidden of hiddenStacks) {
                if (start >= hidden.start && end <= hidden.end && depth >= hidden.depth) return true;
            }
            return false;
        }

        function recalculateLayout() {
            const visibleFrames = frames.filter(f => !isFrameHidden(f));
            const hiddenFramesList = frames.filter(f => isFrameHidden(f));
            hiddenFramesList.forEach(f => f.classList.add('hidden'));
            visibleFrames.forEach(f => f.classList.remove('hidden'));
            if (hiddenStacks.size === 0) {
                frames.forEach(f => { f.classList.remove('hidden'); f.style.left = f.dataset.origLeft; f.style.width = f.dataset.origWidth; });
                applySearch();
                return;
            }
            const byDepth = new Map();
            visibleFrames.forEach(f => { const depth = parseInt(f.dataset.depth); if (!byDepth.has(depth)) byDepth.set(depth, []); byDepth.get(depth).push(f); });
            if (byDepth.size === 0) { applySearch(); return; }
            const rootFrames = byDepth.get(0) || [];
            rootFrames.forEach(f => { f.style.left = '0%'; f.style.width = '100%'; f._adjustedLeft = 0; f._adjustedWidth = 100; });
            const maxDepth = Math.max(...Array.from(byDepth.keys()));
            for (let depth = 1; depth <= maxDepth; depth++) {
                const framesAtDepth = byDepth.get(depth) || [];
                const parentFrames = byDepth.get(depth - 1) || [];
                const parentGroups = new Map();
                framesAtDepth.forEach(f => {
                    const fStart = parseInt(f.dataset.origStart);
                    const fEnd = parseInt(f.dataset.origEnd);
                    const parent = parentFrames.find(p => { const pStart = parseInt(p.dataset.origStart); const pEnd = parseInt(p.dataset.origEnd); return pStart <= fStart && pEnd >= fEnd; });
                    if (parent) {
                        const parentKey = parent.dataset.origStart + '-' + parent.dataset.origEnd;
                        if (!parentGroups.has(parentKey)) parentGroups.set(parentKey, { parent, children: [] });
                        parentGroups.get(parentKey).children.push(f);
                    }
                });
                parentGroups.forEach(({ parent, children }) => {
                    const parentLeft = parent._adjustedLeft !== undefined ? parent._adjustedLeft : parseFloat(parent.style.left);
                    const parentWidth = parent._adjustedWidth !== undefined ? parent._adjustedWidth : parseFloat(parent.style.width);
                    children.sort((a, b) => parseInt(a.dataset.origStart) - parseInt(b.dataset.origStart));
                    const totalChildSamples = children.reduce((sum, c) => sum + (parseInt(c.dataset.origEnd) - parseInt(c.dataset.origStart)), 0);
                    if (totalChildSamples === 0) return;
                    let currentLeft = parentLeft;
                    children.forEach(child => {
                        const childSamples = parseInt(child.dataset.origEnd) - parseInt(child.dataset.origStart);
                        const widthPct = (childSamples / totalChildSamples) * parentWidth;
                        child.style.left = currentLeft + '%';
                        child.style.width = widthPct + '%';
                        child._adjustedLeft = currentLeft;
                        child._adjustedWidth = widthPct;
                        currentLeft += widthPct;
                    });
                });
            }
            frames.forEach(f => { delete f._adjustedLeft; delete f._adjustedWidth; });
            applySearch();
        }

        frames.forEach(frame => {
            frame.addEventListener('mouseenter', (e) => {
                const name = frame.dataset.name;
                const samples = parseInt(frame.dataset.samples);
                const pct = parseFloat(frame.dataset.pct);
                const depth = parseInt(frame.dataset.depth);
                const start = parseInt(frame.dataset.start);
                const end = parseInt(frame.dataset.end);
                let childSamples = 0;
                frames.forEach(f => {
                    if (f.classList.contains('hidden')) return;
                    const fDepth = parseInt(f.dataset.depth);
                    const fStart = parseInt(f.dataset.start);
                    const fEnd = parseInt(f.dataset.end);
                    if (fDepth === depth + 1 && fStart >= start && fEnd <= end) childSamples += parseInt(f.dataset.samples);
                });
                const selfSamples = samples - childSamples;
                const selfPct = (selfSamples / totalSamples * 100).toFixed(2);
                tooltipName.textContent = name;
                tooltipSamples.textContent = formatNumber(samples);
                tooltipPct.textContent = pct.toFixed(2) + '%';
                tooltipSelf.textContent = formatNumber(selfSamples) + ' (' + selfPct + '%)';
                tooltip.classList.add('visible');
            });
            frame.addEventListener('mouseleave', () => { tooltip.classList.remove('visible'); });
            frame.addEventListener('mousemove', (e) => {
                const x = e.clientX + 16;
                const y = e.clientY + 16;
                const rect = tooltip.getBoundingClientRect();
                const maxX = window.innerWidth - rect.width - 16;
                const maxY = window.innerHeight - rect.height - 16;
                tooltip.style.left = Math.min(x, maxX) + 'px';
                tooltip.style.top = Math.min(y, maxY) + 'px';
            });
            frame.addEventListener('click', () => { zoomTo(frame); });
            frame.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                contextTarget = frame;
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('visible');
            });
        });

        function hideContextMenu() { contextMenu.classList.remove('visible'); contextTarget = null; }

        hideStackBtn.addEventListener('click', () => {
            if (!contextTarget) return;
            const start = parseInt(contextTarget.dataset.origStart);
            const end = parseInt(contextTarget.dataset.origEnd);
            const depth = parseInt(contextTarget.dataset.depth);
            hiddenStacks.add({ start, end, depth });
            hideContextMenu();
            recalculateLayout();
            resetBtn.disabled = false;
        });

        resetHiddenBtn.addEventListener('click', () => { hideContextMenu(); resetAll(); });

        function zoomTo(frame) {
            if (!frame || frame.classList.contains('hidden')) return;
            const targetStart = parseInt(frame.dataset.start);
            const targetEnd = parseInt(frame.dataset.end);
            const targetDepth = parseInt(frame.dataset.depth);
            const targetWidth = targetEnd - targetStart;
            zoomedFrame = frame;
            resetBtn.disabled = false;
            frames.forEach(f => {
                if (f.classList.contains('hidden')) return;
                const fStart = parseInt(f.dataset.start);
                const fEnd = parseInt(f.dataset.end);
                const fDepth = parseInt(f.dataset.depth);
                f.classList.remove('zoomed-parent', 'faded');
                if (fEnd <= targetStart || fStart >= targetEnd) { f.classList.add('hidden'); return; }
                if (fDepth < targetDepth && fStart <= targetStart && fEnd >= targetEnd) { f.classList.add('zoomed-parent'); f.style.left = '0%'; f.style.width = '100%'; return; }
                const newStart = Math.max(0, fStart - targetStart);
                const newEnd = Math.min(targetWidth, fEnd - targetStart);
                const newWidth = newEnd - newStart;
                const leftPct = (newStart / targetWidth) * 100;
                const widthPct = (newWidth / targetWidth) * 100;
                f.style.left = leftPct + '%';
                f.style.width = widthPct + '%';
            });
            applySearch();
        }

        function resetAll() {
            zoomedFrame = null;
            hiddenStacks.clear();
            resetBtn.disabled = true;
            searchTerm = null;
            searchInput.value = '';
            frames.forEach(f => { f.classList.remove('hidden', 'zoomed-parent', 'faded', 'highlight'); f.style.left = f.dataset.origLeft; f.style.width = f.dataset.origWidth; });
            matchedStat.style.display = 'none';
            clearSearchBtn.style.display = 'none';
        }

        function applySearch() {
            if (!searchTerm) {
                frames.forEach(f => { if (!f.classList.contains('hidden')) f.classList.remove('highlight', 'faded'); });
                matchedStat.style.display = 'none';
                clearSearchBtn.style.display = 'none';
                return;
            }
            let regex;
            try { regex = new RegExp(searchTerm, 'i'); } catch (e) { return; }
            let matchedSamples = 0;
            let visibleSamples = 0;
            frames.forEach(f => {
                if (f.classList.contains('hidden')) return;
                const samples = parseInt(f.dataset.samples);
                const name = f.dataset.name;
                if (!f.classList.contains('zoomed-parent')) visibleSamples = Math.max(visibleSamples, samples);
                if (regex.test(name)) { f.classList.add('highlight'); f.classList.remove('faded'); matchedSamples += samples; }
                else { f.classList.remove('highlight'); f.classList.add('faded'); }
            });
            const matchedPct = visibleSamples > 0 ? (matchedSamples / visibleSamples * 100) : 0;
            matchedValue.textContent = matchedPct.toFixed(1) + '%';
            matchedStat.style.display = 'flex';
            clearSearchBtn.style.display = 'block';
        }

        function clearSearch() { searchTerm = null; searchInput.value = ''; applySearch(); if (hiddenStacks.size === 0 && !zoomedFrame) resetBtn.disabled = true; }

        document.addEventListener('click', (e) => { if (!contextMenu.contains(e.target) && !e.target.closest('.frame')) hideContextMenu(); });
        searchInput.addEventListener('input', (e) => { searchTerm = e.target.value || null; applySearch(); if (searchTerm) resetBtn.disabled = false; });
        resetBtn.addEventListener('click', resetAll);
        clearSearchBtn.addEventListener('click', clearSearch);
    })();
</script>
</body>

</html>